using UnityEngine;
using Mirror;
using System.Collections.Generic;

public class ClassicSnakeHead : NetworkBehaviour
{
    public GameObject bodySegmentPrefab;
    public float moveInterval = 0.15f;
    public float gridSize = 1f;
    public float collisionOffset = 0.1f;

    private Vector3 direction = Vector3.forward;
    private float timer;

    private List<Vector3> positions = new List<Vector3>();
    private readonly SyncList<GameObject> syncedBody = new SyncList<GameObject>();

    public override void OnStartClient()
    {
        base.OnStartClient();
        positions.Add(transform.position);

        if (!isServer)
        {
            syncedBody.Callback += OnBodySynced;
        }
    }

    private void OnBodySynced(SyncList<GameObject>.Operation op, int index, GameObject oldItem, GameObject newItem)
    {
        // На клиентах добавляем к списку
    }

    void Update()
    {
        if (!isLocalPlayer) return;

        // Дискретное управление
        if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))
        {
            if (direction != Vector3.back) direction = Vector3.forward;
        }
        else if (Input.GetKeyDown(KeyCode.DownArrow) || Input.GetKeyDown(KeyCode.S))
        {
            if (direction != Vector3.forward) direction = Vector3.back;
        }
        else if (Input.GetKeyDown(KeyCode.LeftArrow) || Input.GetKeyDown(KeyCode.A))
        {
            if (direction != Vector3.right) direction = Vector3.left;
        }
        else if (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.D))
        {
            if (direction != Vector3.left) direction = Vector3.right;
        }

        // Движение по таймеру
        timer += Time.deltaTime;
        if (timer >= moveInterval)
        {
            timer = 0f;
            Move();
        }
    }

    void Move()
    {
        Vector3 newPos = transform.position + direction * gridSize;
        transform.position = newPos;

        positions.Insert(0, newPos);

        for (int i = 0; i < syncedBody.Count; i++)
        {
            if (syncedBody[i] != null)
            {
                syncedBody[i].transform.position = positions[Mathf.Clamp(i + 1, 0, positions.Count - 1)];
            }
        }

        if (positions.Count > syncedBody.Count + 1)
            positions.RemoveAt(positions.Count - 1);

        CheckSelfCollision();
    }

    void CheckSelfCollision()
    {
        for (int i = 1; i < syncedBody.Count; i++)
        {
            if (Vector3.Distance(transform.position, syncedBody[i].transform.position) < collisionOffset)
            {
                CmdResetSnake();
                break;
            }
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!isLocalPlayer) return;

        if (other.CompareTag("Food"))
        {
            CmdEatFood(other.gameObject);
        }
    }

    [Command]
    void CmdEatFood(GameObject food)
    {
        SnakeFood f = food.GetComponent<SnakeFood>();
        if (f != null)
        {
            f.Respawn();
            CmdAddSegment();
        }
    }

    [Command]
    void CmdAddSegment()
    {
        GameObject segment = Instantiate(bodySegmentPrefab, transform.position, Quaternion.identity);
        NetworkServer.Spawn(segment);
        syncedBody.Add(segment);
    }

    [Command]
    void CmdResetSnake()
    {
        for (int i = 0; i < syncedBody.Count; i++)
        {
            if (syncedBody[i] != null)
                NetworkServer.Destroy(syncedBody[i]);
        }
        syncedBody.Clear();
        positions.Clear();
        positions.Add(transform.position);
    }
}





using UnityEngine;
using Mirror;

public class SnakeFood : NetworkBehaviour
{
    public Vector2 spawnAreaMin = new Vector2(-10, -10);
    public Vector2 spawnAreaMax = new Vector2(10, 10);

    public override void OnStartServer()
    {
        base.OnStartServer();
        Respawn(); // ТОЛЬКО НА СЕРВЕРЕ
    }

    [Server]
    public void Respawn()
    {
        float x = Mathf.Round(Random.Range(spawnAreaMin.x, spawnAreaMax.x));
        float z = Mathf.Round(Random.Range(spawnAreaMin.y, spawnAreaMax.y));
        transform.position = new Vector3(x, 0.5f, z);
    }
}
