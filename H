using UnityEngine;
using Mirror;
using System.Collections.Generic;

public class ClassicSnakeHead : NetworkBehaviour
{
    [Header("Settings")]
    public GameObject bodySegmentPrefab;
    public float moveInterval = 0.15f;
    public float gridSize = 1f;
    public float collisionOffset = 0.1f;

    private float timer;
    private Vector3 direction = Vector3.forward;

    // Список всех позиций головы и тела
    [SyncVar] private Vector3 lastHeadPosition;
    private List<GameObject> bodySegments = new List<GameObject>();
    private readonly SyncList<Vector3> syncedPositions = new SyncList<Vector3>();

    public override void OnStartServer()
    {
        base.OnStartServer();
        syncedPositions.Clear();
        syncedPositions.Add(transform.position);
    }

    public override void OnStartClient()
    {
        base.OnStartClient();
        syncedPositions.Callback += OnPositionsChanged;
    }

    void Update()
    {
        if (!isLocalPlayer) return;

        // Управление (дискретное)
        if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))
            if (direction != Vector3.back) direction = Vector3.forward;

        if (Input.GetKeyDown(KeyCode.DownArrow) || Input.GetKeyDown(KeyCode.S))
            if (direction != Vector3.forward) direction = Vector3.back;

        if (Input.GetKeyDown(KeyCode.LeftArrow) || Input.GetKeyDown(KeyCode.A))
            if (direction != Vector3.right) direction = Vector3.left;

        if (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.D))
            if (direction != Vector3.left) direction = Vector3.right;

        // Движение
        timer += Time.deltaTime;
        if (timer >= moveInterval)
        {
            timer = 0f;
            CmdMove(direction);
        }
    }

    [Command]
    void CmdMove(Vector3 dir)
    {
        Vector3 newHeadPos = transform.position + dir * gridSize;
        lastHeadPosition = newHeadPos;
        transform.position = newHeadPos;

        // Обновляем список позиций
        syncedPositions.Insert(0, newHeadPos);
        if (syncedPositions.Count > bodySegments.Count + 1)
            syncedPositions.RemoveAt(syncedPositions.Count - 1);

        // Обновляем позиции сегментов
        for (int i = 0; i < bodySegments.Count; i++)
        {
            if (bodySegments[i] != null)
                bodySegments[i].transform.position = syncedPositions[Mathf.Min(i + 1, syncedPositions.Count - 1)];
        }

        CheckSelfCollision();
    }

    void OnPositionsChanged(SyncList<Vector3>.Operation op, int index, Vector3 oldItem, Vector3 newItem)
    {
        // Клиенты: синхронизация позиций
        for (int i = 0; i < bodySegments.Count; i++)
        {
            if (index == i + 1 && bodySegments[i] != null)
            {
                bodySegments[i].transform.position = newItem;
            }
        }
    }

    void CheckSelfCollision()
    {
        for (int i = 1; i < bodySegments.Count; i++)
        {
            if (Vector3.Distance(transform.position, bodySegments[i].transform.position) < collisionOffset)
            {
                CmdResetSnake();
                break;
            }
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!isLocalPlayer) return;

        if (other.CompareTag("Food"))
        {
            CmdEatFood(other.gameObject);
        }
    }

    [Command]
    void CmdEatFood(GameObject food)
    {
        SnakeFood f = food.GetComponent<SnakeFood>();
        if (f != null)
        {
            f.Respawn();
            CmdAddSegment();
        }
    }

    [Command]
    void CmdAddSegment()
    {
        GameObject segment = Instantiate(bodySegmentPrefab, transform.position, Quaternion.identity);
        NetworkServer.Spawn(segment, connectionToClient);
        bodySegments.Add(segment);
    }

    [Command]
    void CmdResetSnake()
    {
        foreach (var seg in bodySegments)
        {
            if (seg != null)
                NetworkServer.Destroy(seg);
        }
        bodySegments.Clear();
        syncedPositions.Clear();
        syncedPositions.Add(transform.position);
    }
}
