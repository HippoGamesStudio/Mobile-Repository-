using UnityEngine;
using Mirror;
using System.Collections.Generic;

public class ClassicSnakeHead : NetworkBehaviour
{
    [Header("Settings")]
    public GameObject bodySegmentPrefab;
    public float moveInterval = 0.15f;
    public float gridSize = 1f;
    public float collisionOffset = 0.1f;

    private float timer;
    private Vector3 direction = Vector3.forward;

    [SyncVar] private Vector3 syncedHeadPosition;
    private readonly SyncList<Vector3> syncedPositions = new SyncList<Vector3>();
    private List<GameObject> bodySegments = new List<GameObject>();

    public override void OnStartServer()
    {
        base.OnStartServer();
        syncedPositions.Clear();
        syncedPositions.Add(transform.position);
        syncedHeadPosition = transform.position;
    }

    public override void OnStartClient()
    {
        base.OnStartClient();
        syncedPositions.Callback += OnPositionsChanged;
    }

    void Update()
    {
        if (!isLocalPlayer) return;

        // Дискретное управление
        if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))
            if (direction != Vector3.back) direction = Vector3.forward;

        if (Input.GetKeyDown(KeyCode.DownArrow) || Input.GetKeyDown(KeyCode.S))
            if (direction != Vector3.forward) direction = Vector3.back;

        if (Input.GetKeyDown(KeyCode.LeftArrow) || Input.GetKeyDown(KeyCode.A))
            if (direction != Vector3.right) direction = Vector3.left;

        if (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.D))
            if (direction != Vector3.left) direction = Vector3.right;

        timer += Time.deltaTime;
        if (timer >= moveInterval)
        {
            timer = 0f;
            CmdMove(direction);
        }
    }

    void LateUpdate()
    {
        if (!isLocalPlayer)
        {
            transform.position = syncedHeadPosition;

            // Поворот головы
            if (syncedPositions.Count >= 2)
            {
                Vector3 lookDir = syncedPositions[0] - syncedPositions[1];
                if (lookDir != Vector3.zero)
                    transform.forward = lookDir.normalized;
            }

            // Обновление сегментов
            for (int i = 0; i < bodySegments.Count; i++)
            {
                if (i + 1 < syncedPositions.Count)
                {
                    var segment = bodySegments[i];
                    segment.transform.position = syncedPositions[i + 1];

                    float t = (float)(i + 1) / (bodySegments.Count + 1);
                    float scale = Mathf.Lerp(1f, 0.3f, t);
                    segment.transform.localScale = new Vector3(scale, scale, scale);
                }
            }
        }
    }

    [Command]
    void CmdMove(Vector3 dir)
    {
        Vector3 newPos = transform.position + dir * gridSize;
        transform.position = newPos;
        syncedHeadPosition = newPos;

        // Поворот головы на сервере
        transform.forward = dir;

        syncedPositions.Insert(0, newPos);
        if (syncedPositions.Count > bodySegments.Count + 1)
            syncedPositions.RemoveAt(syncedPositions.Count - 1);

        for (int i = 0; i < bodySegments.Count; i++)
        {
            if (i + 1 < syncedPositions.Count)
            {
                var segment = bodySegments[i];
                segment.transform.position = syncedPositions[i + 1];

                float t = (float)(i + 1) / (bodySegments.Count + 1);
                float scale = Mathf.Lerp(1f, 0.3f, t);
                segment.transform.localScale = new Vector3(scale, scale, scale);
            }
        }

        CheckSelfCollision();
    }

    void OnPositionsChanged(SyncList<Vector3>.Operation op, int index, Vector3 oldItem, Vector3 newItem)
    {
        // Обработка обновлений списка позиций (ничего не делаем — обновляется в LateUpdate)
    }

    void CheckSelfCollision()
    {
        for (int i = 0; i < bodySegments.Count; i++)
        {
            if (Vector3.Distance(transform.position, bodySegments[i].transform.position) < collisionOffset)
            {
                CmdResetSnake();
                break;
            }
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!isLocalPlayer) return;

        if (other.CompareTag("Food"))
        {
            CmdEatFood(other.gameObject);
        }
    }

    [Command]
    void CmdEatFood(GameObject food)
    {
        SnakeFood f = food.GetComponent<SnakeFood>();
        if (f != null)
        {
            f.Respawn();
            CmdAddSegment();
        }
    }

    [Command]
    void CmdAddSegment()
    {
        GameObject segment = Instantiate(bodySegmentPrefab, transform.position, Quaternion.identity);
        NetworkServer.Spawn(segment, connectionToClient);
        bodySegments.Add(segment);
    }

    [Command]
    void CmdResetSnake()
    {
        foreach (var seg in bodySegments)
        {
            if (seg != null)
                NetworkServer.Destroy(seg);
        }

        bodySegments.Clear();
        syncedPositions.Clear();
        syncedPositions.Add(transform.position);
    }
}
